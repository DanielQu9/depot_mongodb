<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <title>ESP32 ç‰©æ–™é¸æ“‡ç³»çµ±</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
      text-align: center;
      width: 100%;
      max-width: 400px;
      color: white;
    }

    h2 {
      margin-top: 0;
      font-size: 24px;
      font-weight: 300;
      margin-bottom: 30px;
      background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .form-group {
      margin-bottom: 20px;
      text-align: left;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
    }

    select {
      width: 100%;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: white;
      font-size: 16px;
      outline: none;
      transition: all 0.3s ease;
    }

    select:focus {
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
    }

    select option {
      background: rgba(102, 126, 234, 0.9);
      color: white;
    }

    .btn {
      width: 100%;
      padding: 14px;
      margin: 10px 0;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn:before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .btn:hover:not(:disabled):before {
      left: 100%;
    }

    .btn-confirm {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      box-shadow: 0 8px 20px rgba(79, 172, 254, 0.3);
    }

    .btn-confirm:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(79, 172, 254, 0.4);
    }

    .btn-send {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
      box-shadow: 0 8px 20px rgba(250, 112, 154, 0.3);
    }

    .btn-send:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(250, 112, 154, 0.4);
    }

    .btn-reset {
      background: linear-gradient(135deg, #ff6b6b 0%, #ffa726 100%);
      color: white;
      box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
    }

    .btn-reset:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(255, 107, 107, 0.4);
    }

    .summary-section {
      margin: 30px 0;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h3 {
      margin-top: 0;
      font-size: 18px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    li {
      background: rgba(255, 255, 255, 0.1);
      margin: 8px 0;
      padding: 12px 16px;
      border-radius: 10px;
      border-left: 4px solid #4facfe;
      font-size: 14px;
      backdrop-filter: blur(5px);
    }

    .loading {
      display: none;
      margin: 10px 0;
    }

    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #4facfe;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .empty-state {
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      padding: 20px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>ESP32 æ™ºèƒ½å–æ–™ç³»çµ±</h2>

    <div class="form-group">
      <label for="å°èºæ¯">å°èºæ¯</label>
      <select id="å°èºæ¯"></select>
    </div>

    <div class="form-group">
      <label for="å¤§èºæ¯">å¤§èºæ¯</label>
      <select id="å¤§èºæ¯"></select>
    </div>

    <div class="form-group">
      <label for="éµç®¡">éµç®¡</label>
      <select id="éµç®¡"></select>
    </div>

    <div class="form-group">
      <label for="å¡‘è† ç®¡">å¡‘è† ç®¡</label>
      <select id="å¡‘è† ç®¡"></select>
    </div>

    <!-- ç§»é™¤ onclick å±¬æ€§ï¼Œæ”¹ç”¨ç´”äº‹ä»¶å§”è¨— -->
    <button class="btn btn-confirm">ç¢ºèªé¸æ“‡</button>

    <div class="summary-section">
      <h3>ğŸ“‹ é¸æ“‡æ¸…å–®</h3>
      <ul id="orderSummary">
        <div class="empty-state">å°šæœªé¸æ“‡ä»»ä½•ç‰©æ–™</div>
      </ul>
    </div>

    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>æ­£åœ¨ç™¼é€æŒ‡ä»¤...</p>
    </div>

    <button class="btn btn-send">ğŸš€ ç¢ºèªé€å‡º</button>
    <button class="btn btn-reset">ğŸ”„ é‡æ–°é¸æ–™</button>
  </div>

  <script>
    class MaterialSelector {
      constructor() {
        this.currentOrder = [];
        this.materials = ["å°èºæ¯", "å¤§èºæ¯", "éµç®¡", "å¡‘è† ç®¡"];
        this.apiConfig = {
          sendUrl: "./sc",
          xarmUrl: "./xc",
          serverUrl: "http://127.0.0.1:5000/menu_post",
          timeout: 10000
        };
        this.isProcessing = false;
        this.configLoaded = false;

        this.init();
      }

      async init() {
        try {
          // å…ˆè¼‰å…¥è¨­å®šæª”
          await this.loadConfig();
          this.generateSelectOptions();
          this.bindEvents();
          this.updateSummary();
          console.log('MaterialSelector åˆå§‹åŒ–å®Œæˆï¼Œè¨­å®šå·²è¼‰å…¥');
        } catch (error) {
          console.error('åˆå§‹åŒ–æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
          // å¦‚æœè¨­å®šæª”è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é è¨­è¨­å®šç¹¼çºŒåŸ·è¡Œ
          this.generateSelectOptions();
          this.bindEvents();
          this.updateSummary();
          this.showToast("âš ï¸ è¨­å®šæª”è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é è¨­è¨­å®š", "warning");
        }
      }

      async loadConfig() {
        try {
          // å¾ç›¸å°è·¯å¾‘è¼‰å…¥è¨­å®šæª”
          const response = await fetch('/config');
          
          if (!response.ok) {
            throw new Error(`ç„¡æ³•è¼‰å…¥è¨­å®šæª”: ${response.status} ${response.statusText}`);
          }

          const config = await response.json();
          
          // æ›´æ–° API è¨­å®š
          //if (config.url) {
          //  this.apiConfig.sendUrl = config.url.sc || this.apiConfig.sendUrl;
          //  this.apiConfig.xarmUrl = config.url.xc || this.apiConfig.xarmUrl;
          //  this.apiConfig.serverUrl = config.url.server || this.apiConfig.serverUrl;
          //}

          this.configLoaded = true;
          console.log('è¨­å®šæª”è¼‰å…¥æˆåŠŸ:', this.apiConfig);
          
        } catch (error) {
          console.error('è¼‰å…¥è¨­å®šæª”æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
          throw error;
        }
      }

      generateSelectOptions() {
        const optionsHtml = Array.from({ length: 11 }, (_, i) =>
          `<option value="${i}">${i === 0 ? 'ä¸é¸æ“‡' : `${i} å€‹`}</option>`
        ).join('');

        this.materials.forEach(material => {
          const selectElement = document.getElementById(material);
          if (selectElement) {
            selectElement.innerHTML = optionsHtml;
          }
        });
      }

      bindEvents() {
        // ä½¿ç”¨äº‹ä»¶å§”è¨—ä¾†è™•ç†æŒ‰éˆ•é»æ“Š
        document.addEventListener('click', (e) => {
          // é˜²æ­¢é‡è¤‡è§¸ç™¼
          if (this.isProcessing) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }

          if (e.target.matches('.btn-confirm')) {
            e.preventDefault();
            this.confirmSelection(e);
          } else if (e.target.matches('.btn-send')) {
            e.preventDefault();
            this.sendToESP32();
          } else if (e.target.matches('.btn-reset')) {
            e.preventDefault();
            this.resetOrder(e);
          }
        });

        // ç›£è½é¸æ“‡æ¡†è®ŠåŒ–ï¼Œæä¾›å³æ™‚é è¦½
        this.materials.forEach(material => {
          const selectElement = document.getElementById(material);
          if (selectElement) {
            selectElement.addEventListener('change', () => {
              this.previewSelection();
            });
          }
        });
      }

      previewSelection() {
        // å³æ™‚é è¦½é¸æ“‡ï¼Œä½†ä¸ç¢ºèª
        const tempOrder = [];
        this.materials.forEach(material => {
          const qty = parseInt(document.getElementById(material)?.value || 0);
          if (qty > 0) {
            tempOrder.push({ material, quantity: qty });
          }
        });

        // è¦–è¦ºæç¤ºæ˜¯å¦æœ‰è®Šæ›´
        const hasChanges = !this.arraysEqual(tempOrder, this.currentOrder);
        const confirmBtn = document.querySelector('.btn-confirm');
        if (confirmBtn) {
          confirmBtn.style.opacity = hasChanges ? '1' : '0.7';
        }
      }

      confirmSelection(event) {
        if (this.isProcessing) return;

        try {
          this.isProcessing = true;
          const newOrder = [];

          this.materials.forEach(material => {
            const element = document.getElementById(material);
            if (element) {
              const qty = parseInt(element.value || 0);
              if (qty > 0) {
                newOrder.push({ material, quantity: qty });
              }
            }
          });

          this.currentOrder = newOrder;
          this.updateSummary();
          this.addButtonFeedback(event.target);

          // æˆåŠŸæç¤º
          if (newOrder.length > 0) {
            this.showToast("âœ… é¸æ“‡å·²ç¢ºèª", "success");
          }

        } catch (error) {
          console.error('ç¢ºèªé¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
          this.showToast("âŒ ç¢ºèªé¸æ“‡å¤±æ•—", "error");
        } finally {
          // çŸ­æš«å»¶é²å¾Œé‡ç½®è™•ç†ç‹€æ…‹
          setTimeout(() => {
            this.isProcessing = false;
          }, 300);
        }
      }

      updateSummary() {
        const summaryElement = document.getElementById("orderSummary");
        if (!summaryElement) return;

        summaryElement.innerHTML = "";

        if (this.currentOrder.length === 0) {
          summaryElement.innerHTML = '<div class="empty-state">å°šæœªé¸æ“‡ä»»ä½•ç‰©æ–™</div>';
          return;
        }

        const fragment = document.createDocumentFragment();
        this.currentOrder.forEach(item => {
          const li = document.createElement("li");
          li.innerHTML = `<strong>${this.escapeHtml(item.material)}</strong>ï¼š${item.quantity} å€‹`;
          fragment.appendChild(li);
        });

        summaryElement.appendChild(fragment);
      }

      async sendToESP32() {
        if (this.isProcessing) return;
        
        if (this.currentOrder.length === 0) {
          this.showToast("âš ï¸ è«‹å…ˆé¸æ“‡ç‰©æ–™", "warning");
          return;
        }

        const sendButton = document.querySelector('.btn-send');

        try {
          this.isProcessing = true;
          console.log('é–‹å§‹ç™¼é€æŒ‡ä»¤...', this.currentOrder); // Debug log
          
          // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
          this.toggleLoading(true);
          this.toggleButton(sendButton, false);

          const promises = [
            this.sendRequest(this.apiConfig.sendUrl, "è‡ªèµ°è»Š"),
            this.sendRequest(this.apiConfig.xarmUrl, "æ©Ÿæ¢°è‡‚"),
            this.sendRequest(this.apiConfig.serverUrl, "ä¼ºæœå™¨")
          ];

          const results = await Promise.allSettled(promises);
          
          const successes = results.filter(result => result.status === 'fulfilled');
          const failures = results.filter(result => result.status === 'rejected');
          
          console.log('ç™¼é€çµæœ:', { successes: successes.length, failures: failures.length });

          if (successes.length === 3) {
            this.showToast("âœ… æŒ‡ä»¤å·²æˆåŠŸé€å‡ºè‡³è‡ªèµ°è»Šã€æ©Ÿæ¢°è‡‚èˆ‡ä¼ºæœå™¨ï¼", "success");
          } else if (successes.length > 0) {
            const failedTargets = [];
            if (results[0].status === 'rejected') failedTargets.push('è‡ªèµ°è»Š');
            if (results[1].status === 'rejected') failedTargets.push('æ©Ÿæ¢°è‡‚');
            if (results[2].status === 'rejected') failedTargets.push('ä¼ºæœå™¨');
            
            this.showToast(`âš ï¸ éƒ¨åˆ†ç™¼é€æˆåŠŸï¼Œå¤±æ•—ç›®æ¨™ï¼š${failedTargets.join('ã€')}`, "warning");
            console.warn('éƒ¨åˆ†ç™¼é€å¤±æ•—:', failures.map(f => f.reason));
          } else {
            throw new Error('æ‰€æœ‰ç›®æ¨™ç™¼é€å¤±æ•—');
          }

        } catch (error) {
          console.error('ç™¼é€æŒ‡ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
          this.showToast(`âŒ ç™¼é€å¤±æ•—ï¼š${error.message}`, "error");
        } finally {
          this.toggleLoading(false);
          this.toggleButton(sendButton, true);
          
          // å»¶é²é‡ç½®è™•ç†ç‹€æ…‹ï¼Œé˜²æ­¢å¿«é€Ÿé‡è¤‡é»æ“Š
          setTimeout(() => {
            this.isProcessing = false;
          }, 1000);
        }
      }

      async sendRequest(url, deviceName) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.apiConfig.timeout);

        try {
          console.log(`ç™¼é€åˆ° ${deviceName}:`, url, this.currentOrder);
          
          let requestBody;
          let headers = {
            "Content-Type": "application/json",
            "Accept": "application/json"
          };

          if (deviceName === "ä¼ºæœå™¨") {
            requestBody = {
              items: this.currentOrder,
              timestamp: new Date().toISOString(),
              source: "ESP32æ™ºèƒ½å–æ–™ç³»çµ±"
            };
          } else {
            requestBody = { items: this.currentOrder };
          }
          
          const response = await fetch(url, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(requestBody),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            const errorText = await response.text().catch(() => 'Unknown error');
            throw new Error(`${deviceName}å›æ‡‰éŒ¯èª¤ (${response.status}): ${errorText}`);
          }

          const result = await response.json().catch(() => ({ success: true }));
          console.log(`${deviceName}å›æ‡‰:`, result);
          return result;
          
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            throw new Error(`${deviceName}è«‹æ±‚è¶…æ™‚ (${this.apiConfig.timeout/1000}ç§’)`);
          }
          throw new Error(`${deviceName}ç™¼é€å¤±æ•—: ${error.message}`);
        }
      }

      resetOrder(event) {
        if (this.isProcessing) return;

        try {
          this.isProcessing = true;
          
          this.materials.forEach(material => {
            const element = document.getElementById(material);
            if (element) {
              element.value = 0;
            }
          });

          this.currentOrder = [];
          this.updateSummary();
          this.addButtonFeedback(event.target);
          this.showToast("ğŸ”„ å·²é‡è¨­é¸æ–™", "info");

        } catch (error) {
          console.error('é‡è¨­æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
          this.showToast("âŒ é‡è¨­å¤±æ•—", "error");
        } finally {
          setTimeout(() => {
            this.isProcessing = false;
          }, 300);
        }
      }

      // å·¥å…·æ–¹æ³•
      addButtonFeedback(button) {
        if (!button) return;

        button.style.transform = 'scale(0.95)';
        setTimeout(() => {
          button.style.transform = '';
        }, 150);
      }

      toggleLoading(show) {
        const loadingElement = document.getElementById("loading");
        if (loadingElement) {
          loadingElement.style.display = show ? "block" : "none";
        }
      }

      toggleButton(button, enabled) {
        if (!button) return;

        button.disabled = !enabled;
        button.style.opacity = enabled ? '1' : '0.6';
        button.style.cursor = enabled ? 'pointer' : 'not-allowed';
      }

      escapeHtml(text) {
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
      }

      arraysEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        return arr1.every((item, index) => {
          const other = arr2[index];
          return item.material === other?.material && item.quantity === other?.quantity;
        });
      }

      showToast(message, type = "info") {
        // ç§»é™¤ç¾æœ‰çš„ toast
        const existingToast = document.querySelector('.custom-toast');
        if (existingToast) {
          existingToast.remove();
        }

        const colors = {
          success: '#4CAF50',
          error: '#f44336',
          warning: '#ff9800',
          info: '#2196F3'
        };

        const toast = document.createElement('div');
        toast.className = 'custom-toast';
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%) translateY(-20px);
          background: rgba(255, 255, 255, 0.95);
          backdrop-filter: blur(20px);
          color: #333;
          padding: 15px 25px;
          border-radius: 10px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
          z-index: 1000;
          font-weight: 500;
          border-left: 4px solid ${colors[type] || colors.info};
          opacity: 0;
          transition: all 0.3s ease;
          max-width: 90vw;
          word-wrap: break-word;
        `;

        toast.textContent = message;
        document.body.appendChild(toast);

        // è§¸ç™¼é€²å…¥å‹•ç•«
        requestAnimationFrame(() => {
          toast.style.opacity = '1';
          toast.style.transform = 'translateX(-50%) translateY(0)';
        });

        // è‡ªå‹•ç§»é™¤
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(-50%) translateY(-20px)';
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }
    }

    // åˆå§‹åŒ–æ‡‰ç”¨
    document.addEventListener('DOMContentLoaded', () => {
      window.materialSelector = new MaterialSelector();
    });
  </script>
</body>

</html>